# Design Overview

## Primary Tools

**Frontend**: `Javascript`/`React`/`Webpack`/Airbnb-styleguide -- a standard frontend stack in keeping with Teleport's typical stack. For the sake of expediency I'll build for the latest stable Chrome release and will ignore mobile optimization.

**Backend**: `Go 1.15` standard library plus external dependencies (discussed below)

## Router/Dispatcher

The router/dispatcher will use the popular [gorilla/mux](https://github.com/gorilla/mux) package rather than the standard `http.ServeMux`. The primary reason for this choice is that `gorilla` provides a cousin package [gorilla/websocket](https://github.com/gorilla/websocket) for handling websockets. Technically `gorilla/websocket` should be compatible with `go`'s standard `http` package, however using the two `gorilla` packages together ensures superior online support and avoids any possible idiosyncratic incompatibilities. Additionally `gorilla` seemingly has a reputation for better developer ergonomics than the standard package.

Note: My plan is to initially implement the system with client-side polling (the level 2 project), and then time/energy permitting attempt to refactor the system to hit the level 3/4 project which would make use of websockets.

## Browser-client Security

Browser-clients will use a username/password to authenticate and then be granted an access token which will serve as a session ID and used to authorize subsequent requests (sent in the Authorization header in Bearer Token format). The server will be built to only accept SSL encrypted connections which will prevent (all but the most sophisticated) MITM attackers from stealing the token from the header and/or other information sent over the wire. The server will also respond to all requests with the following headers (in addition to `gorilla/mux` defaults):

```
X-XSS-Protection: 1; mode=block
X-Frame-Options: deny
Strict-Transport-Security: max-age= 6307200; includeSubDomains
Content-Security-Policy: default-src 'self'
X-Permitted-Cross-Domain-Policies: none
```

#### Access Token Design

Access/session-id tokens will be [32 bytes](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#session-id-length) (256-bits of entropy) and generated by a CSPRNG (`crypto/rand`). See [here](https://blog.questionable.services/article/generating-secure-random-numbers-crypto-rand/) for an implementation that also base64 encodes the tokens for use in http headers.

#### Session Management

Server side, sessions will be stored in a global in-memory map indexed by session-id. They will have 12 hour absolute timeout (the user has to log in at least once every 12 hours) to prevent an attacker who manages to compromise a token from causing damage indefinitely. This UX could be improved by implementing a refresh token system however I will consider that out of scope for this project. Sessions will keep track of when they are created, and each access token protected call will use that value to check if sessions have timed out. On timeout (or if the user logs out), the session key and all of its data will be deleted. This global in-memory map should be seen as a temporary solution for prototyping, as it introduces the potential for data races if concurrently processing requests are accessing/modifying the same values in the same session. Additionally, if a user fails to log out and/or clears their browser cache (see discussion of `localStorage` below), a session might wind up "stuck" in memory and never deleted, which is a marginal security/engineering concern. Ultimately I'm imagining this system would be swapped out in favor of a more sophisticated out of the box solution like a Redis store, or a memory safe, self-cleaning implementation like [scs](https://github.com/alexedwards/scs), but will again consider that out of scope unless directed otherwise.

Browser side, access/session-id tokens will be stored in `localStorage` and thus will be saved across browser sessions; this makes them relatively less secure than if they were stored in `sessionStorage`, but in general is a better UX.

#### CSRF protection

Because our security model does not use cookies and CSRF attacks exploit cookie-based models, we do not need to concern ourselves with CSRF protection.

## Fakeiot-client security

Given the design of the [fakeiot](https://github.com/gravitational/fakeiot) simulation where the bearer token is passed from the command line, the security model between the fakeiot-client and the server is technically a [pre-shared key](https://en.wikipedia.org/wiki/Pre-shared_key) model. As mentioned in the "Browser-client security" section above, the server will be built to only accept SSL encrypted connections which will prevent (all but the most sophisticated) MITM attackers from stealing the token from the header and/or other information sent over the wire.

#### API key design

Exactly the same as described in "Access Token Design" above.

#### Considerations

Because this key must be shared with fakeiot clients before they're started, and they have no means of re-authenticating, these keys will have no absolute timeout. This is a relatively insecure security model, because if a single client or the server is compromised (or MITM'd) and the key is stolen, the whole system is compromised (not just a single client). There are a variety of methods for [hardening](https://hackernoon.com/improve-the-security-of-api-keys-v5kp3wdu) our keys with varying degrees of engineering effort required to implement, but will be considered well beyond the scope of this project. One important consideration is that in my implementation of the server, I will ensure that I distinguish between fakeiot-client api tokens and browser client access/session-id tokens, so that a leak of the api token securing the relatively less security `/metrics` POST endpoint can't be used by an attacker as an access/session-id token to mess with higher value endpoints.

The primary advantage of this model is that its extremely cheap to implement. MITM risk can be significantly reduced by requiring SSL connections so that the token is never mistakenly sent in an unencrypted header. And given that the fakeiot-clients are only talking to the `/metrics` endpoint, compromise is relatively low risk -- a successful attacker could try to spam new accounts or force some unfortunate account to upgrade before they'd actually hit their user limit, but these would likely be caught manually and are reversible; or they could try some species of SQL/Log injection attack, but these can be mitigated by standard methods; or they could attempt a DoS/DDoS attack, but this can be defended against via rate limiting protection.

## Database

For easy installation and usage I will use SQLite3 as the RDBMS. If this project was expected to scale up massively, I would elect to migrate over to Postgres. For additional security I might add password protection and encryption to the database file (or SSL in the case of Postgres), but for the sake of avoiding extra complexity and scope creep in this project I will simply label these as theoretical TODO's.

Database queries will be sent with the `database/sql` package which uses [prepared statements](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html#defense-option-1-prepared-statements-with-parameterized-queries) [behind the scenes](http://go-database-sql.org/prepared.html)

#### Data model

| account    |      |       |               |            |            |
| ---------- | ---- | ----- | ------------- | ---------- | ---------- |
| account_id | plan | email | password_hash | created_at | updated_at |

Note: passwords will be salted and hashed using the [bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt) package and later will be verified against the hash.

| user    |            |           |            |            |
| ------- | ---------- | --------- | ---------- | ---------- |
| user_id | account_id | is_active | created_at | updated_at |

| logins     |         |           |
| ---------- | ------- | --------- |
| account_id | user_id | timestamp |

| apikey   |            |
| -------- | ---------- |
| key_hash | account_id |

## Endpoints

#### `/login`

**POST**: Public. A valid username/pwd combo creates a new session and gives the user a corresponding access/session-id token.

#### `/logout`

**DELETE**: Access/session-id token protected. Deletes corresponding session.

#### `/metrics`

**POST**: API key protected. The request body must contain a pre registered `account_id` and the Authorization header it's valid corresponding API key. Updates the `logins` table with a new row. For each new `account_id`/`user_id` combination that's recieved, a new entry in the `user` table is created; the `is_active` column is determined by whether the corresponding account has exceeded it's plan's usage limits.

**GET**: Access/session-id token protected. Returns the plan's current number of active users and plan type/user-limit.

#### `/updgrade`

**PATCH**: Access/session-id token protected. Upgrades `account`'s `plan` column, and updates all previously inactive users on that account to active.

As a final security consideration, these endpoints might be protected by a rate limiting middleware. Unless directed otherwise I will consider this out of scope for this project.
